name: Deploy Next Hire APP

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  AWS_REGION: us-east-2
  ECR_REPOSITORY: next-hire-app
  AWS_ACCOUNT_ID: 618166615317

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Run Django tests
      run: |
        python manage.py test --noinput

    - name: Security scan
      run: |
        pip install bandit safety
        bandit -r . -f json -o bandit-report.json || true
        safety check --json --output safety-report.json || true

  determine-version:
    needs: test
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
    permissions:
      contents: write
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Get next semantic version
      id: version
      run: |
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        echo "Latest tag: $LATEST_TAG"
        
        VERSION=${LATEST_TAG#v}
        MAJOR=$(echo $VERSION | cut -d. -f1)
        MINOR=$(echo $VERSION | cut -d. -f2)
        PATCH=$(echo $VERSION | cut -d. -f3)
        
        NEW_PATCH=$((PATCH + 1))
        NEW_VERSION="v$MAJOR.$MINOR.$NEW_PATCH"
        
        echo "New version: $NEW_VERSION"
        echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT

    - name: Create and push Git tag
      run: |
        NEW_VERSION="${{ steps.version.outputs.version }}"
        echo "Creating Git tag: $NEW_VERSION"
        
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        
        git tag -a "$NEW_VERSION" -m "Release $NEW_VERSION"
        git push origin "$NEW_VERSION"
        
        echo "Tag $NEW_VERSION created and pushed"

  build-and-push:
    needs: determine-version
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ needs.determine-version.outputs.version }}
    permissions:
      id-token: write
      contents: read
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Set version
      id: version
      run: |
        VERSION="${{ needs.determine-version.outputs.version }}"
        echo "image-tag=$VERSION" >> $GITHUB_OUTPUT
        echo "Using image tag: $VERSION"

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ASSUME_ROLE }}
        aws-region: ${{ env.AWS_REGION }}
        role-session-name: GitHubActions-Build

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64
        build-args: |
          BUILD_VERSION=${{ steps.version.outputs.image-tag }}
        tags: |
          ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ steps.version.outputs.image-tag }}
          ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:latest
        push: true

    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ steps.version.outputs.image-tag }}
        format: 'sarif'
        output: 'trivy-results.sarif'

  deploy-to-dev:
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: 
      name: dev
    permissions:
      id-token: write
      contents: read

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ASSUME_ROLE }}
        aws-region: ${{ env.AWS_REGION }}
        role-session-name: GitHubActions-Dev

    - name: Update task definition with new image
      id: update-task-def
      run: |
        VERSION="${{ needs.build-and-push.outputs.image-tag }}"
        NEW_IMAGE="${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:$VERSION"
        
        echo "Updating task definition with image: $NEW_IMAGE"
        
        # Get current task definition
        TASK_DEFINITION=$(aws ecs describe-task-definition \
          --task-definition next-hire-app-dev \
          --query 'taskDefinition' \
          --output json)
        
        # Update the image in the container definition
        NEW_TASK_DEF=$(echo $TASK_DEFINITION | jq --arg IMAGE "$NEW_IMAGE" \
          '.containerDefinitions[0].image = $IMAGE | 
           del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)')
        
        # Register new task definition
        NEW_TASK_INFO=$(aws ecs register-task-definition \
          --cli-input-json "$NEW_TASK_DEF" \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text)
        
        echo "New task definition registered: $NEW_TASK_INFO"
        echo "task-definition-arn=$NEW_TASK_INFO" >> $GITHUB_OUTPUT

    - name: Deploy to Development
      run: |
        VERSION="${{ needs.build-and-push.outputs.image-tag }}"
        echo "Deploying version $VERSION to Development"
        
        aws ecs update-service \
          --cluster next-hire-cluster-dev \
          --service next-hire-app-dev \
          --task-definition ${{ steps.update-task-def.outputs.task-definition-arn }} \
          --force-new-deployment

    - name: Wait for dev deployment
      run: |
        echo "Waiting for Development deployment..."
        aws ecs wait services-stable \
          --cluster next-hire-cluster-dev \
          --services next-hire-app-dev
        echo "Development deployment completed!"

  deploy-to-staging:
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: 
      name: staging
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ASSUME_ROLE }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-Staging

      - name: Get image tag for staging
        id: get-staging-tag
        run: |
          if [ -n "${{ needs.build-and-push.outputs.image-tag }}" ]; then
            echo "Using build job image tag: ${{ needs.build-and-push.outputs.image-tag }}"
            echo "image-tag=${{ needs.build-and-push.outputs.image-tag }}" >> $GITHUB_OUTPUT
          else
            LATEST_TAG=$(aws ecr describe-images \
              --repository-name ${{ env.ECR_REPOSITORY }} \
              --query 'sort_by(imageDetails, &imagePushedAt)[-1].imageTags[0]' \
              --output text 2>/dev/null || echo "")
            if [ -n "$LATEST_TAG" ] && [ "$LATEST_TAG" != "None" ] && [ "$LATEST_TAG" != "latest" ]; then
              echo "Using latest ECR image tag: $LATEST_TAG"
              echo "image-tag=$LATEST_TAG" >> $GITHUB_OUTPUT
            else
              echo "No image tags found in ECR"
              exit 1
            fi
          fi

      - name: Update task definition with new image
        id: update-task-def
        run: |
          VERSION="${{ steps.get-staging-tag.outputs.image-tag }}"
          NEW_IMAGE="${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:$VERSION"
          
          echo "Updating task definition with image: $NEW_IMAGE"
          
          # Get current task definition
          TASK_DEFINITION=$(aws ecs describe-task-definition \
            --task-definition next-hire-app-stg \
            --query 'taskDefinition' \
            --output json)
          
          # Update the image in the container definition
          NEW_TASK_DEF=$(echo $TASK_DEFINITION | jq --arg IMAGE "$NEW_IMAGE" \
            '.containerDefinitions[0].image = $IMAGE | 
             del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)')
          
          # Register new task definition
          NEW_TASK_INFO=$(aws ecs register-task-definition \
            --cli-input-json "$NEW_TASK_DEF" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo " New task definition registered: $NEW_TASK_INFO"
          echo "task-definition-arn=$NEW_TASK_INFO" >> $GITHUB_OUTPUT

      - name: Deploy to Staging
        run: |
          VERSION="${{ steps.get-staging-tag.outputs.image-tag }}"
          echo "Deploying version $VERSION to Staging"
          echo "Image: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:$VERSION"
          
          aws ecs update-service \
            --cluster next-hire-cluster-stg \
            --service next-hire-app-stg \
            --task-definition ${{ steps.update-task-def.outputs.task-definition-arn }} \
            --force-new-deployment

      - name: Wait for staging deployment
        run: |
          echo "Waiting for Staging deployment..."
          aws ecs wait services-stable \
            --cluster next-hire-cluster-stg \
            --services next-hire-app-stg
          echo " Staging deployment completed!"

  # deploy-to-production:
  #   needs: build-and-push
  #   if: false
  #   runs-on: ubuntu-latest
  #   environment: production
  #   permissions:
  #     id-token: write
  #     contents: read

  #   steps:
  #   - name: Configure AWS credentials
  #     uses: aws-actions/configure-aws-credentials@v4
  #     with:
  #       role-to-assume: ${{ secrets.AWS_ASSUME_ROLE }}
  #       aws-region: ${{ env.AWS_REGION }}
  #       role-session-name: GitHubActions-Production

  #   - name: Get image tag for production
  #     id: get-production-tag
  #     run: |
  #       if [ -n "${{ needs.build-and-push.outputs.image-tag }}" ]; then
  #         echo "Using build job image tag: ${{ needs.build-and-push.outputs.image-tag }}"
  #         echo "image-tag=${{ needs.build-and-push.outputs.image-tag }}" >> $GITHUB_OUTPUT
  #       else
  #         LATEST_TAG=$(aws ecr describe-images \
  #           --repository-name ${{ env.ECR_REPOSITORY }} \
  #           --query 'sort_by(imageDetails, &imagePushedAt)[-1].imageTags[0]' \
  #           --output text 2>/dev/null || echo "")
  #         if [ -n "$LATEST_TAG" ] && [ "$LATEST_TAG" != "None" ] && [ "$LATEST_TAG" != "latest" ]; then
  #           echo "Using latest ECR image tag: $LATEST_TAG"
  #           echo "image-tag=$LATEST_TAG" >> $GITHUB_OUTPUT
  #         else
  #           echo "No image tags found in ECR"
  #           exit 1
  #         fi
  #       fi

  #   - name: Update task definition with new image
  #     id: update-task-def
  #     run: |
  #       VERSION="${{ steps.get-production-tag.outputs.image-tag }}"
  #       NEW_IMAGE="${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:$VERSION"
  #       
  #       echo "Updating task definition with image: $NEW_IMAGE"
  #       
  #       # Get current task definition
  #       TASK_DEFINITION=$(aws ecs describe-task-definition \
  #         --task-definition next-hire-app-prd \
  #         --query 'taskDefinition' \
  #         --output json)
  #       
  #       # Update the image in the container definition
  #       NEW_TASK_DEF=$(echo $TASK_DEFINITION | jq --arg IMAGE "$NEW_IMAGE" \
  #         '.containerDefinitions[0].image = $IMAGE | 
  #          del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)')
  #       
  #       # Register new task definition
  #       NEW_TASK_INFO=$(aws ecs register-task-definition \
  #         --cli-input-json "$NEW_TASK_DEF" \
  #         --query 'taskDefinition.taskDefinitionArn' \
  #         --output text)
  #       
  #       echo "New task definition registered: $NEW_TASK_INFO"
  #       echo "task-definition-arn=$NEW_TASK_INFO" >> $GITHUB_OUTPUT

  #   - name: Deploy to Production
  #     run: |
  #       VERSION="${{ steps.get-production-tag.outputs.image-tag }}"
  #       echo "Deploying version $VERSION to Production"
  #       echo "Image: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:$VERSION"
  #       
  #       aws ecs update-service \
  #         --cluster next-hire-cluster-prd \
  #         --service next-hire-app-prd \
  #         --task-definition ${{ steps.update-task-def.outputs.task-definition-arn }} \
  #         --force-new-deployment

  #   - name: Wait for production deployment
  #     run: |
  #       echo "Waiting for Production deployment..."
  #       aws ecs wait services-stable \
  #         --cluster next-hire-cluster-prd \
  #         --services next-hire-app-prd
  #       echo "Production deployment completed!"

  #   - name: Deployment success notification
  #     run: |
  #       VERSION="${{ steps.get-production-tag.outputs.image-tag }}"
  #       echo "Version $VERSION successfully deployed to Production!"
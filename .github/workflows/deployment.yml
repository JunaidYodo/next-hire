name: Deploy Next Hire APP

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  AWS_REGION: us-east-2
  ECR_REPOSITORY: next-hire-app
  ECS_CLUSTER: next-hire-cluster
  ECS_SERVICE: next-hire-app
  AWS_ACCOUNT_ID: 618166615317

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Run Django tests
      run: |
        python manage.py test --noinput

    - name: Security scan
      run: |
        pip install bandit safety
        bandit -r . -f json -o bandit-report.json || true
        safety check --json --output safety-report.json || true

  determine-version:
    needs: test
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Get next semantic version
      id: version
      run: |
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        echo "Latest tag: $LATEST_TAG"
        
        VERSION=${LATEST_TAG#v}
        MAJOR=$(echo $VERSION | cut -d. -f1)
        MINOR=$(echo $VERSION | cut -d. -f2)
        PATCH=$(echo $VERSION | cut -d. -f3)
        
        NEW_PATCH=$((PATCH + 1))
        NEW_VERSION="v$MAJOR.$MINOR.$NEW_PATCH"
        
        echo "New version: $NEW_VERSION"
        echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT

  build-and-push:
    needs: determine-version
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ needs.determine-version.outputs.version }}
    permissions:
      id-token: write
      contents: read
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Set version
      id: version
      run: |
        VERSION="${{ needs.determine-version.outputs.version }}"
        echo "image-tag=$VERSION" >> $GITHUB_OUTPUT
        echo "Using image tag: $VERSION"

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ASSUME_ROLE }}
        aws-region: ${{ env.AWS_REGION }}
        role-session-name: GitHubActions-Build

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64
        build-args: |
          BUILD_VERSION=${{ steps.version.outputs.image-tag }}
        tags: |
          ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ steps.version.outputs.image-tag }}
          ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:latest
        push: true

    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ steps.version.outputs.image-tag }}
        format: 'sarif'
        output: 'trivy-results.sarif'

  deploy-to-dev:
    needs: build-and-push
    runs-on: ubuntu-latest
    environment:
      name: dev
    permissions:
      id-token: write
      contents: read

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ASSUME_ROLE }}
        aws-region: ${{ env.AWS_REGION }}
        role-session-name: GitHubActions-Dev

    - name: Deploy to Development
      run: |
        VERSION="${{ needs.build-and-push.outputs.image-tag }}"
        echo "Deploying version $VERSION to Development"
        
        aws ecs update-service \
          --cluster next-hire-cluster-dev \
          --service $ECS_SERVICE \
          --force-new-deployment

    - name: Wait for dev deployment
      run: |
        echo "Waiting for Development deployment..."
        aws ecs wait services-stable \
          --cluster next-hire-cluster-dev \
          --services $ECS_SERVICE
        echo "Development deployment completed!"

  deploy-to-staging:
    needs: build-and-push
    if: false
    runs-on: ubuntu-latest
    environment:
      name: staging
      url: https://staging.example.com
    permissions:
      id-token: write
      contents: read

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ASSUME_ROLE }}
        aws-region: ${{ env.AWS_REGION }}
        role-session-name: GitHubActions-Staging

    - name: Get image tag for staging
      id: get-staging-tag
      run: |
        if [ -n "${{ needs.build-and-push.outputs.image-tag }}" ]; then
          echo "Using build job image tag: ${{ needs.build-and-push.outputs.image-tag }}"
          echo "image-tag=${{ needs.build-and-push.outputs.image-tag }}" >> $GITHUB_OUTPUT
        else
          LATEST_TAG=$(aws ecr describe-images \
            --repository-name $ECR_REPOSITORY \
            --query 'sort_by(imageDetails, &imagePushedAt)[-1].imageTags[0]' \
            --output text 2>/dev/null || echo "")
          if [ -n "$LATEST_TAG" ] && [ "$LATEST_TAG" != "None" ] && [ "$LATEST_TAG" != "latest" ]; then
            echo "Using latest ECR image tag: $LATEST_TAG"
            echo "image-tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          else
            echo "‚ùå No image tags found in ECR"
            exit 1
          fi
        fi

    - name: Deploy to Staging
      run: |
        VERSION="${{ steps.get-staging-tag.outputs.image-tag }}"
        echo "üöÄ Deploying version $VERSION to Staging"
        echo "Image: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:$VERSION"
        
        aws ecs update-service \
          --cluster next-hire-cluster-stg \
          --service $ECS_SERVICE-staging \
          --force-new-deployment

    - name: Wait for staging deployment
      run: |
        echo "Waiting for Staging deployment..."
        aws ecs wait services-stable \
          --cluster next-hire-cluster-stg \
          --services $ECS_SERVICE-staging
        echo "Staging deployment completed!"

  deploy-to-production:
    needs: build-and-push
    if: false
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://production.example.com
    permissions:
      id-token: write
      contents: read

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ASSUME_ROLE }}
        aws-region: ${{ env.AWS_REGION }}
        role-session-name: GitHubActions-Production

    - name: Get image tag for production
      id: get-production-tag
      run: |
        if [ -n "${{ needs.build-and-push.outputs.image-tag }}" ]; then
          echo "Using build job image tag: ${{ needs.build-and-push.outputs.image-tag }}"
          echo "image-tag=${{ needs.build-and-push.outputs.image-tag }}" >> $GITHUB_OUTPUT
        else
          LATEST_TAG=$(aws ecr describe-images \
            --repository-name $ECR_REPOSITORY \
            --query 'sort_by(imageDetails, &imagePushedAt)[-1].imageTags[0]' \
            --output text 2>/dev/null || echo "")
          if [ -n "$LATEST_TAG" ] && [ "$LATEST_TAG" != "None" ] && [ "$LATEST_TAG" != "latest" ]; then
            echo "Using latest ECR image tag: $LATEST_TAG"
            echo "image-tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          else
            echo "‚ùå No image tags found in ECR"
            exit 1
          fi
        fi

    - name: Deploy to Production
      run: |
        VERSION="${{ steps.get-production-tag.outputs.image-tag }}"
        echo "üöÄ Deploying version $VERSION to Production"
        echo "Image: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:$VERSION"
        
        aws ecs update-service \
          --cluster next-hire-cluster-prd \
          --service $ECS_SERVICE \
          --force-new-deployment

    - name: Wait for production deployment
      run: |
        echo "Waiting for Production deployment..."
        aws ecs wait services-stable \
          --cluster next-hire-cluster-prd \
          --services $ECS_SERVICE
        echo "Production deployment completed!"

    - name: Deployment success notification
      run: |
        VERSION="${{ steps.get-production-tag.outputs.image-tag }}"
        echo "Version $VERSION successfully deployed to Production!"